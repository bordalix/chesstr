const SYMBOLS = "pnbrqkPNBRQK", DEFAULT_POSITION = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", TERMINATION_MARKERS = ["1-0", "0-1", "1/2-1/2", "*"], PAWN_OFFSETS = { b: [16, 32, 17, 15], w: [-16, -32, -17, -15] }, PIECE_OFFSETS = { n: [-18, -33, -31, -14, 18, 33, 31, 14], b: [-17, -15, 17, 15], r: [-16, 1, 16, -1], q: [-17, -16, -15, 1, 17, 16, 15, -1], k: [-17, -16, -15, 1, 17, 16, 15, -1] }, ATTACKS = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20], RAYS = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17], SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }, BITS = { NORMAL: 1, CAPTURE: 2, BIG_PAWN: 4, EP_CAPTURE: 8, PROMOTION: 16, KSIDE_CASTLE: 32, QSIDE_CASTLE: 64 }, RANK_1 = 7, RANK_2 = 6, RANK_3 = 5, RANK_4 = 4, RANK_5 = 3, RANK_6 = 2, RANK_7 = 1, RANK_8 = 0, SQUARE_MAP = { a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7, a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23, a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39, a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55, a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71, a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87, a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103, a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119 }, ROOKS = { w: [{ square: SQUARE_MAP.a1, flag: BITS.QSIDE_CASTLE }, { square: SQUARE_MAP.h1, flag: BITS.KSIDE_CASTLE },], b: [{ square: SQUARE_MAP.a8, flag: BITS.QSIDE_CASTLE }, { square: SQUARE_MAP.h8, flag: BITS.KSIDE_CASTLE },] }, PARSER_STRICT = 0, PARSER_SLOPPY = 1; function get_disambiguator(r, e) { for (var n = r.from, $ = r.to, t = r.piece, o = 0, i = 0, a = 0, l = 0, f = e.length; l < f; l++) { var u = e[l].from, _ = e[l].to; t === e[l].piece && n !== u && $ === _ && (o++, rank(n) === rank(u) && i++, file(n) === file(u) && a++) } return o > 0 ? i > 0 && a > 0 ? algebraic(n) : a > 0 ? algebraic(n).charAt(1) : algebraic(n).charAt(0) : "" } function infer_piece_type(r) { var e = r.charAt(0); if (e >= "a" && e <= "h") { if (r.match(/[a-h]\d.*[a-h]\d/)) return; return PAWN } return "o" === (e = e.toLowerCase()) ? KING : e } function stripped_san(r) { return r.replace(/=/, "").replace(/[+#]?[?!]*$/, "") } function rank(r) { return r >> 4 } function file(r) { return 15 & r } function algebraic(r) { var e = file(r), n = rank(r); return "abcdefgh".substring(e, e + 1) + "87654321".substring(n, n + 1) } function swap_color(r) { return r === WHITE ? BLACK : WHITE } function is_digit(r) { return -1 !== "0123456789".indexOf(r) } function clone(r) { var e = r instanceof Array ? [] : {}; for (var n in r) "object" == typeof n ? e[n] = clone(r[n]) : e[n] = r[n]; return e } function trim(r) { return r.replace(/^\s+|\s+$/g, "") } const BLACK = "b", WHITE = "w", EMPTY = -1, PAWN = "p", KNIGHT = "n", BISHOP = "b", ROOK = "r", QUEEN = "q", KING = "k", SQUARES = function () { for (var r = [], e = SQUARE_MAP.a8; e <= SQUARE_MAP.h1; e++) { if (136 & e) { e += 7; continue } r.push(algebraic(e)) } return r }(), FLAGS = { NORMAL: "n", CAPTURE: "c", BIG_PAWN: "b", EP_CAPTURE: "e", PROMOTION: "p", KSIDE_CASTLE: "k", QSIDE_CASTLE: "q" }, Chess = function (r) { var e = Array(128), n = { w: -1, b: -1 }, $ = WHITE, t = { w: 0, b: 0 }, o = -1, i = 0, a = 1, l = [], f = {}, u = {}; function _(r) { void 0 === r && (r = !1), e = Array(128), n = { w: -1, b: -1 }, $ = WHITE, t = { w: 0, b: 0 }, o = -1, i = 0, a = 1, l = [], r || (f = {}), u = {}, v(A()) } function c() { for (var r = [], e = {}, n = function (r) { (r in u) && (e[r] = u[r]) }; l.length > 0;)r.push(K()); for (n(A()); r.length > 0;)N(r.pop()), n(A()); u = e } function s() { p(DEFAULT_POSITION) } function p(r, e) { void 0 === e && (e = !1); var n = r.split(/\s+/), l = n[0], f = 0; if (!S(r).valid) return !1; _(e); for (var u = 0; u < l.length; u++) { var c = l.charAt(u); if ("/" === c) f += 8; else if (is_digit(c)) f += parseInt(c, 10); else { var s = c < "a" ? WHITE : BLACK; h({ type: c.toLowerCase(), color: s }, algebraic(f)), f++ } } return $ = n[1], n[2].indexOf("K") > -1 && (t.w |= BITS.KSIDE_CASTLE), n[2].indexOf("Q") > -1 && (t.w |= BITS.QSIDE_CASTLE), n[2].indexOf("k") > -1 && (t.b |= BITS.KSIDE_CASTLE), n[2].indexOf("q") > -1 && (t.b |= BITS.QSIDE_CASTLE), o = "-" === n[3] ? -1 : SQUARE_MAP[n[3]], i = parseInt(n[4], 10), a = parseInt(n[5], 10), v(A()), !0 } function S(r) { var e = { 0: "No errors.", 1: "FEN string must contain six space-delimited fields.", 2: "6th field (move number) must be a positive integer.", 3: "5th field (half move counter) must be a non-negative integer.", 4: "4th field (en-passant square) is invalid.", 5: "3rd field (castling availability) is invalid.", 6: "2nd field (side to move) is invalid.", 7: "1st field (piece positions) does not contain 8 '/'-delimited rows.", 8: "1st field (piece positions) is invalid [consecutive numbers].", 9: "1st field (piece positions) is invalid [invalid piece].", 10: "1st field (piece positions) is invalid [row too large].", 11: "Illegal en-passant square" }, n = r.split(/\s+/); if (6 !== n.length) return { valid: !1, error_number: 1, error: e[1] }; if (isNaN(parseInt(n[5])) || 0 >= parseInt(n[5], 10)) return { valid: !1, error_number: 2, error: e[2] }; if (isNaN(parseInt(n[4])) || 0 > parseInt(n[4], 10)) return { valid: !1, error_number: 3, error: e[3] }; if (!/^(-|[abcdefgh][36])$/.test(n[3])) return { valid: !1, error_number: 4, error: e[4] }; if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(n[2])) return { valid: !1, error_number: 5, error: e[5] }; if (!/^(w|b)$/.test(n[1])) return { valid: !1, error_number: 6, error: e[6] }; var $ = n[0].split("/"); if (8 !== $.length) return { valid: !1, error_number: 7, error: e[7] }; for (var t = 0; t < $.length; t++) { for (var o = 0, i = !1, a = 0; a < $[t].length; a++)if (isNaN($[t][a])) { if (!/^[prnbqkPRNBQK]$/.test($[t][a])) return { valid: !1, error_number: 9, error: e[9] }; o += 1, i = !1 } else { if (i) return { valid: !1, error_number: 8, error: e[8] }; o += parseInt($[t][a], 10), i = !0 } if (8 !== o) return { valid: !1, error_number: 10, error: e[10] } } return "3" == n[3][1] && "w" == n[1] || "6" == n[3][1] && "b" == n[1] ? { valid: !1, error_number: 11, error: e[11] } : { valid: !0, error_number: 0, error: e[0] } } function A() { for (var r = 0, n = "", l = SQUARE_MAP.a8; l <= SQUARE_MAP.h1; l++) { if (null == e[l]) r++; else { r > 0 && (n += r, r = 0); var f = e[l].color, u = e[l].type; n += f === WHITE ? u.toUpperCase() : u.toLowerCase() } l + 1 & 136 && (r > 0 && (n += r), l !== SQUARE_MAP.h1 && (n += "/"), r = 0, l += 8) } var _ = ""; t[WHITE] & BITS.KSIDE_CASTLE && (_ += "K"), t[WHITE] & BITS.QSIDE_CASTLE && (_ += "Q"), t[BLACK] & BITS.KSIDE_CASTLE && (_ += "k"), t[BLACK] & BITS.QSIDE_CASTLE && (_ += "q"), _ = _ || "-"; var c = -1 === o ? "-" : algebraic(o); return [n, $, _, c, i, a].join(" ") } function g(r) { for (var e = 0; e < r.length; e += 2)"string" == typeof r[e] && "string" == typeof r[e + 1] && (f[r[e]] = r[e + 1]); return f } function v(r) { l.length > 0 || (r !== DEFAULT_POSITION ? (f.SetUp = "1", f.FEN = r) : (delete f.SetUp, delete f.FEN)) } function E(r) { var n = e[SQUARE_MAP[r]]; return n ? { type: n.type, color: n.color } : null } function h(r, $) { if (!("type" in r && "color" in r) || -1 === "pnbrqkPNBRQK".indexOf(r.type.toLowerCase()) || !($ in SQUARE_MAP)) return !1; var t = SQUARE_MAP[$]; return (r.type != KING || -1 == n[r.color] || n[r.color] == t) && (e[t] = { type: r.type, color: r.color }, r.type === KING && (n[r.color] = t), v(A()), !0) } function T(r, e, n, t, o) { var i = { color: $, from: e, to: n, flags: t, piece: r[e].type }; return o && (i.flags |= BITS.PROMOTION, i.promotion = o), r[n] ? i.captured = r[n].type : t & BITS.EP_CAPTURE && (i.captured = PAWN), i } function I(r) { function i(r, e, n, $, t) { if (r[n].type === PAWN && (0 === rank($) || 7 === rank($))) for (var o = ["q", "r", "b", "n"], i = 0, a = o.length; i < a; i++)e.push(T(r, n, $, t, o[i])); else e.push(T(r, n, $, t)) } var a = [], l = $, f = swap_color(l), u = { b: 1, w: 6 }, _ = SQUARE_MAP.a8, c = SQUARE_MAP.h1, s = !1, p = void 0 === r || !("legal" in r) || r.legal, S = void 0 === r || !("piece" in r) || "string" != typeof r.piece || r.piece.toLowerCase(); if (void 0 !== r && "square" in r) { if (!(r.square in SQUARE_MAP)) return []; _ = c = SQUARE_MAP[r.square], s = !0 } for (var A = _; A <= c; A++) { if (136 & A) { A += 7; continue } var g = e[A]; if (null != g && g.color === l) { if (g.type === PAWN && (!0 === S || S === PAWN)) { var v = A + PAWN_OFFSETS[l][0]; if (null == e[v]) { i(e, a, A, v, BITS.NORMAL); var v = A + PAWN_OFFSETS[l][1]; u[l] === rank(A) && null == e[v] && i(e, a, A, v, BITS.BIG_PAWN) } for (E = 2; E < 4; E++) { var v = A + PAWN_OFFSETS[l][E]; 136 & v || (null != e[v] && e[v].color === f ? i(e, a, A, v, BITS.CAPTURE) : v === o && i(e, a, A, o, BITS.EP_CAPTURE)) } } else if (!0 === S || S === g.type) for (var E = 0, h = PIECE_OFFSETS[g.type].length; E < h; E++)for (var I = PIECE_OFFSETS[g.type][E], v = A; !(136 & (v += I));) { if (null == e[v]) i(e, a, A, v, BITS.NORMAL); else { if (e[v].color === l) break; i(e, a, A, v, BITS.CAPTURE); break } if ("n" === g.type || "k" === g.type) break } } } if ((!0 === S || S === KING) && (!s || c === n[l])) { if (t[l] & BITS.KSIDE_CASTLE) { var b = n[l], R = b + 2; null != e[b + 1] || null != e[R] || d(f, n[l]) || d(f, b + 1) || d(f, R) || i(e, a, n[l], R, BITS.KSIDE_CASTLE) } if (t[l] & BITS.QSIDE_CASTLE) { var b = n[l], R = b - 2; null != e[b - 1] || null != e[b - 2] || null != e[b - 3] || d(f, n[l]) || d(f, b - 1) || d(f, R) || i(e, a, n[l], R, BITS.QSIDE_CASTLE) } } if (!p) return a; for (var m = [], A = 0, h = a.length; A < h; A++)N(a[A]), P(l) || m.push(a[A]), K(); return m } function b(r, e) { var n = ""; if (r.flags & BITS.KSIDE_CASTLE) n = "O-O"; else if (r.flags & BITS.QSIDE_CASTLE) n = "O-O-O"; else { if (r.piece !== PAWN) { var $ = get_disambiguator(r, e); n += r.piece.toUpperCase() + $ } r.flags & (BITS.CAPTURE | BITS.EP_CAPTURE) && (r.piece === PAWN && (n += algebraic(r.from)[0]), n += "x"), n += algebraic(r.to), r.flags & BITS.PROMOTION && (n += "=" + r.promotion.toUpperCase()) } return N(r), R() && (m() ? n += "#" : n += "+"), K(), n } function d(r, n) { for (var $ = SQUARE_MAP.a8; $ <= SQUARE_MAP.h1; $++) { if (136 & $) { $ += 7; continue } if (null != e[$] && e[$].color === r) { var t = e[$], o = $ - n, i = o + 119; if (ATTACKS[i] & 1 << SHIFTS[t.type]) { if (t.type === PAWN) { if (o > 0) { if (t.color === WHITE) return !0 } else if (t.color === BLACK) return !0; continue } if ("n" === t.type || "k" === t.type) return !0; for (var a = RAYS[i], l = $ + a, f = !1; l !== n;) { if (null != e[l]) { f = !0; break } l += a } if (!f) return !0 } } } return !1 } function P(r) { return d(swap_color(r), n[r]) } function R() { return P($) } function m() { return R() && 0 === I().length } function C() { return !R() && 0 === I().length } function O() { for (var r = {}, n = [], $ = 0, t = 0, o = SQUARE_MAP.a8; o <= SQUARE_MAP.h1; o++) { if (t = (t + 1) % 2, 136 & o) { o += 7; continue } var i = e[o]; i && (r[i.type] = i.type in r ? r[i.type] + 1 : 1, "b" === i.type && n.push(t), $++) } if (2 === $ || 3 === $ && (1 === r.b || 1 === r.n)) return !0; if ($ === r.b + 2) { for (var a = 0, l = n.length, o = 0; o < l; o++)a += n[o]; if (0 === a || a === l) return !0 } return !1 } function B() { for (var r = [], e = {}, n = !1; ;) { var $ = K(); if (!$) break; r.push($) } for (; ;) { var t = A().split(" ").slice(0, 4).join(" "); if (e[t] = t in e ? e[t] + 1 : 1, e[t] >= 3 && (n = !0), !r.length) break; N(r.pop()) } return n } function N(r) { var f, u = $, _ = swap_color(u); if (f = r, l.push({ move: f, kings: { b: n.b, w: n.w }, turn: $, castling: { b: t.b, w: t.w }, ep_square: o, half_moves: i, move_number: a }), e[r.to] = e[r.from], e[r.from] = null, r.flags & BITS.EP_CAPTURE && ($ === BLACK ? e[r.to - 16] = null : e[r.to + 16] = null), r.flags & BITS.PROMOTION && (e[r.to] = { type: r.promotion, color: u }), e[r.to].type === KING) { if (n[e[r.to].color] = r.to, r.flags & BITS.KSIDE_CASTLE) { var c = r.to - 1, s = r.to + 1; e[c] = e[s], e[s] = null } else if (r.flags & BITS.QSIDE_CASTLE) { var c = r.to + 1, s = r.to - 2; e[c] = e[s], e[s] = null } t[u] = "" } if (t[u]) { for (var p = 0, S = ROOKS[u].length; p < S; p++)if (r.from === ROOKS[u][p].square && t[u] & ROOKS[u][p].flag) { t[u] ^= ROOKS[u][p].flag; break } } if (t[_]) { for (var p = 0, S = ROOKS[_].length; p < S; p++)if (r.to === ROOKS[_][p].square && t[_] & ROOKS[_][p].flag) { t[_] ^= ROOKS[_][p].flag; break } } o = r.flags & BITS.BIG_PAWN ? "b" === $ ? r.to - 16 : r.to + 16 : -1, r.piece === PAWN ? i = 0 : r.flags & (BITS.CAPTURE | BITS.EP_CAPTURE) ? i = 0 : i++, $ === BLACK && a++, $ = swap_color($) } function K() { var r, f, u, _ = l.pop(); if (null == _) return null; var c = _.move; n = _.kings, $ = _.turn, t = _.castling, o = _.ep_square, i = _.half_moves, a = _.move_number; var s = $, p = swap_color($); return e[c.from] = e[c.to], e[c.from].type = c.piece, e[c.to] = null, c.flags & BITS.CAPTURE ? e[c.to] = { type: c.captured, color: p } : c.flags & BITS.EP_CAPTURE && (e[r = s === BLACK ? c.to - 16 : c.to + 16] = { type: PAWN, color: p }), c.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE) && (c.flags & BITS.KSIDE_CASTLE ? (f = c.to + 1, u = c.to - 1) : c.flags & BITS.QSIDE_CASTLE && (f = c.to - 2, u = c.to + 1), e[f] = e[u], e[u] = null), c } function y(r, e) { for (var n = stripped_san(r), $ = 0; $ < 2; $++) { if (1 == $) { if (!e) return null; var t = !1, o = n.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/); if (o) { var i = o[1], a = o[2], l = o[3], f = o[4]; 1 == a.length && (t = !0) } else { var o = n.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/); if (o) { var i = o[1], a = o[2], l = o[3], f = o[4]; if (1 == a.length) var t = !0 } } } for (var u = infer_piece_type(n), _ = I({ legal: !0, piece: i || u }), c = 0, s = _.length; c < s; c++)switch ($) { case 0: if (n === stripped_san(b(_[c], _))) return _[c]; break; case 1: if (o) { if ((!i || i.toLowerCase() == _[c].piece) && SQUARE_MAP[a] == _[c].from && SQUARE_MAP[l] == _[c].to && (!f || f.toLowerCase() == _[c].promotion)) return _[c]; if (t) { var p = algebraic(_[c].from); if ((!i || i.toLowerCase() == _[c].piece) && SQUARE_MAP[l] == _[c].to && (a == p[0] || a == p[1]) && (!f || f.toLowerCase() == _[c].promotion)) return _[c] } } } } return null } function L(r) { var e = clone(r); e.san = b(e, I({ legal: !0 })), e.to = algebraic(e.to), e.from = algebraic(e.from); var n = ""; for (var $ in BITS) BITS[$] & e.flags && (n += FLAGS[$]); return e.flags = n, e } return void 0 === r ? p(DEFAULT_POSITION) : p(r), { load: function (r) { return p(r) }, reset: function () { return s() }, moves: function (r) { for (var e = I(r), n = [], $ = 0, t = e.length; $ < t; $++)void 0 !== r && "verbose" in r && r.verbose ? n.push(L(e[$])) : n.push(b(e[$], I({ legal: !0 }))); return n }, in_check: function () { return R() }, in_checkmate: function () { return m() }, in_stalemate: function () { return C() }, in_draw: function () { return i >= 100 || C() || O() || B() }, insufficient_material: function () { return O() }, in_threefold_repetition: function () { return B() }, game_over: function () { return i >= 100 || m() || C() || O() || B() }, validate_fen: function (r) { return S(r) }, fen: function () { return A() }, board: function () { for (var r = [], n = [], $ = SQUARE_MAP.a8; $ <= SQUARE_MAP.h1; $++)null == e[$] ? n.push(null) : n.push({ square: algebraic($), type: e[$].type, color: e[$].color }), $ + 1 & 136 && (r.push(n), n = [], $ += 8); return r }, pgn: function (r) { var e = "object" == typeof r && "string" == typeof r.newline_char ? r.newline_char : "\n", n = "object" == typeof r && "number" == typeof r.max_width ? r.max_width : 0, $ = [], t = !1; for (var o in f) $.push("[" + o + ' "' + f[o] + '"]' + e), t = !0; t && l.length && $.push(e); for (var i = function (r) { var e = u[A()]; return void 0 !== e && (r = `${r}${r.length > 0 ? " " : ""}{${e}}`), r }, _ = []; l.length > 0;)_.push(K()); var c = [], s = ""; for (0 === _.length && c.push(i("")); _.length > 0;) { s = i(s); var p = _.pop(); if (l.length || "b" !== p.color) "w" === p.color && (s.length && c.push(s), s = a + "."); else { let S = `${a}. ...`; s = s ? `${s} ${S}` : S } s = s + " " + b(p, I({ legal: !0 })), N(p) } if (s.length && c.push(i(s)), void 0 !== f.Result && c.push(f.Result), 0 === n) return $.join("") + c.join(" "); for (var g = function () { return $.length > 0 && " " === $[$.length - 1] && ($.pop(), !0) }, v = 0, o = 0; o < c.length; o++) { if (v + c[o].length > n && c[o].includes("{")) { v = function (r, t) { for (var o of t.split(" ")) if (o) { if (r + o.length > n) { for (; g();)r--; $.push(e), r = 0 } $.push(o), r += o.length, $.push(" "), r++ } return g() && r--, r }(v, c[o]); continue } v + c[o].length > n && 0 !== o ? (" " === $[$.length - 1] && $.pop(), $.push(e), v = 0) : 0 !== o && ($.push(" "), v++), $.push(c[o]), v += c[o].length } return $.join("") }, load_pgn: function (r, e) { var n = void 0 !== e && "sloppy" in e && e.sloppy; function $(r) { return r.replace(/\\/g, "\\") } r = r.trim(); var t = "object" == typeof e && "string" == typeof e.newline_char ? e.newline_char : "\r?\n", o = RegExp("^(\\[((?:" + $(t) + ")|.)*\\])(?:\\s*" + $(t) + "){2}"), i = o.test(r) ? o.exec(r)[1] : ""; s(); var a = function r(e, n) { for (var t = "object" == typeof n && "string" == typeof n.newline_char ? n.newline_char : "\r?\n", o = {}, i = e.split(RegExp($(t))), a = "", l = "", f = 0; f < i.length; f++) { var u = /^\s*\[([A-Za-z]+)\s*"(.*)"\s*\]\s*$/; a = i[f].replace(u, "$1"), l = i[f].replace(u, "$2"), trim(a).length > 0 && (o[a] = l) } return o }(i, e), l = ""; for (var _ in a) "fen" === _.toLowerCase() && (l = a[_]), g([_, a[_]]); if (n) { if (l && !p(l, !0)) return !1 } else if ("1" === a.SetUp && !("FEN" in a && p(a.FEN, !0))) return !1; for (var c = function (r) { return Array.from(r).map(function (r) { return 128 > r.charCodeAt(0) ? r.charCodeAt(0).toString(16) : encodeURIComponent(r).replace(/\%/g, "").toLowerCase() }).join("") }, S = function (r) { return r = r.replace(RegExp($(t), "g"), " "), `{${c(r.slice(1, r.length - 1))}}` }, v = r.replace(i, "").replace(RegExp(`({[^}]*})+?|;([^${$(t)}]*)`, "g"), function (r, e, n) { return void 0 !== e ? S(e) : " " + S(`{${n.slice(1)}}`) }).replace(RegExp($(t), "g"), " "), E = /(\([^\(\)]+\))+?/g; E.test(v);)v = v.replace(E, ""); v = (v = (v = v.replace(/\d+\.(\.\.)?/g, "")).replace(/\.\.\./g, "")).replace(/\$\d+/g, ""); var h = trim(v).split(RegExp(/\s+/)); h = h.join(",").replace(/,,+/g, ",").split(","); for (var T = "", I = "", b = 0; b < h.length; b++) { var d = function (r) { if (r.startsWith("{") && r.endsWith("}")) { var e; return 0 == (e = r.slice(1, r.length - 1)).length ? "" : decodeURIComponent("%" + e.match(/.{1,2}/g).join("%")) } }(h[b]); if (void 0 !== d) { u[A()] = d; continue } if (null == (T = y(h[b], n))) { if (!(TERMINATION_MARKERS.indexOf(h[b]) > -1)) return !1; I = h[b] } else I = "", N(T) } return I && Object.keys(f).length && !f.Result && g(["Result", I]), !0 }, header: function () { return g(arguments) }, turn: function () { return $ }, move: function (r, e) { var n = void 0 !== e && "sloppy" in e && e.sloppy, $ = null; if ("string" == typeof r) $ = y(r, n); else if ("object" == typeof r) { for (var t = I(), o = 0, i = t.length; o < i; o++)if (r.from === algebraic(t[o].from) && r.to === algebraic(t[o].to) && (!("promotion" in t[o]) || r.promotion === t[o].promotion)) { $ = t[o]; break } } if (!$) return null; var a = L($); return N($), a }, undo: function () { var r = K(); return r ? L(r) : null }, clear: function () { return _() }, put: function (r, e) { return h(r, e) }, get: function (r) { return E(r) }, ascii() { for (var r = "   +------------------------+\n", n = SQUARE_MAP.a8; n <= SQUARE_MAP.h1; n++) { if (0 === file(n) && (r += " " + "87654321"[rank(n)] + " |"), null == e[n]) r += " . "; else { var $ = e[n].type; r += " " + (e[n].color === WHITE ? $.toUpperCase() : $.toLowerCase()) + " " } n + 1 & 136 && (r += "|\n", n += 8) } return r += "   +------------------------+\n", r += "     a  b  c  d  e  f  g  h" }, remove: function (r) { var $, t; return t = E($ = r), e[SQUARE_MAP[$]] = null, t && t.type === KING && (n[t.color] = -1), v(A()), t }, perft: function (r) { return function r(e) { for (var n = I({ legal: !1 }), t = 0, o = $, i = 0, a = n.length; i < a; i++) { if (N(n[i]), !P(o)) { if (e - 1 > 0) { var l = r(e - 1); t += l } else t++ } K() } return t }(r) }, square_color: function (r) { if (r in SQUARE_MAP) { var e = SQUARE_MAP[r]; return (rank(e) + file(e)) % 2 == 0 ? "light" : "dark" } return null }, history: function (r) { for (var e = [], n = [], $ = void 0 !== r && ("verbose" in r) && r.verbose; l.length > 0;)e.push(K()); for (; e.length > 0;) { var t = e.pop(); $ ? n.push(L(t)) : n.push(b(t, I({ legal: !0 }))), N(t) } return n }, get_comment: function () { return u[A()] }, set_comment: function (r) { u[A()] = r.replace("{", "[").replace("}", "]") }, delete_comment: function () { var r = u[A()]; return delete u[A()], r }, get_comments: function () { return c(), Object.keys(u).map(function (r) { return { fen: r, comment: u[r] } }) }, delete_comments: function () { return c(), Object.keys(u).map(function (r) { var e = u[r]; return delete u[r], { fen: r, comment: e } }) } } };